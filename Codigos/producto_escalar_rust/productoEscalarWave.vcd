$timescale 1 ps $end
$scope module uut $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 1 # start $end
$var wire 8 $ a $end
$var wire 8 % b $end
$var wire 1 & valid $end
$var wire 16 ' result $end
$var wire 1 ( busy $end
$scope module accumulator $end
$var wire 16 ) d $end
$var wire 16 * q $end
$var wire 1 + clk $end
$upscope $end
$scope module counter $end
$var wire 8 , d $end
$var wire 8 - q $end
$var wire 1 . clk $end
$upscope $end
$scope module e_busy $end
$var wire 1 / d $end
$var wire 1 0 q $end
$var wire 1 1 clk $end
$upscope $end
$var wire 8 2 max_count $end
$scope module mul $end
$var wire 8 3 a $end
$var wire 8 4 b $end
$var wire 16 5 resul $end
$upscope $end
$upscope $end
$enddefinitions $end
$dumpvars
0!
1"
0#
b00000000 $
b00000000 %
0&
b0000000000000000 '
0(
b0000000000000000 )
b0000000000000000 *
0+
b00000000 ,
b00000000 -
0.
0/
00
01
b00000100 2
b00000000 3
b00000000 4
b0000000000000000 5
$end
#1
1!
1+
1.
11
#2
0!
0"
1#
1(
0+
0.
1/
01
#3
1!
1+
1.
10
11
#4
0!
0#
b00000011 $
b00000100 %
1&
b0000000000001100 )
0+
b00000001 ,
0.
01
b00000011 3
b00000100 4
b0000000000001100 5
#5
1!
b0000000000011000 )
b0000000000001100 *
1+
b00000010 ,
b00000001 -
1.
11
#6
0!
b00000101 $
b00000110 %
b0000000000101010 )
0+
0.
01
b00000101 3
b00000110 4
b0000000000011110 5
#7
1!
b0000000001001000 )
b0000000000101010 *
1+
b00000011 ,
b00000010 -
1.
11
#8
0!
b00000111 $
b00001000 %
b0000000001100010 )
0+
0.
01
b00000111 3
b00001000 4
b0000000000111000 5
#9
1!
b0000000010011010 )
b0000000001100010 *
1+
b00000100 ,
b00000011 -
1.
11
#10
0!
b00001001 $
b00001010 %
b0000000010111100 )
0+
0.
01
b00001001 3
b00001010 4
b0000000001011010 5
#11
1!
b0000000010111100 '
0(
b0000000100010110 )
b0000000010111100 *
1+
b00000101 ,
b00000100 -
1.
0/
11
#12
